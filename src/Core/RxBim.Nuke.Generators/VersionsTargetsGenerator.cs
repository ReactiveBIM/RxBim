namespace RxBim.Nuke.Generators
{
    using System.Collections.Generic;
    using System.Linq;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp.Syntax;

    /// <summary>
    /// Generates NUKE targets for different versions of CAD/BIM applications.
    /// </summary>
    [Generator]
    public class VersionsTargetsGenerator : ISourceGenerator
    {
        private GeneratorExecutionContext _context;

        /// <inheritdoc />
        public void Initialize(GeneratorInitializationContext context)
        {
// #if DEBUG
//             Debugger.Launch();
// #endif
        }

        /// <inheritdoc />
        public void Execute(GeneratorExecutionContext context)
        {
            _context = context;
            var appVersion = _context.Compilation.GetTypeByMetadataName("RxBim.Nuke.Versions.AppVersion");
            if (appVersion is null)
                return;

            var versionNumbers = GetVersionNumbers(appVersion);
            foreach (var versionNumber in versionNumbers)
            {
                var source = GetSource(versionNumber);
                _context.AddSource($"IVersionBuild{versionNumber}.g.cs", source);
            }
        }

        private static IEnumerable<string> GetVersionNumbers(INamespaceOrTypeSymbol appVersion)
        {
            var appVersionValues = appVersion.GetMembers()
                .Where(x => x.IsStatic && x.Kind is SymbolKind.Field)
                .Cast<IFieldSymbol>();

            var numbers = new HashSet<string>();

            foreach (var appVersionValue in appVersionValues)
            {
                if (TryGetVersionNumber(appVersionValue, out var number))
                    numbers.Add(number);
            }

            return numbers;
        }

        private static string GetSource(string versionNumber)
        {
            var source = $@"// <auto-generated/>
#pragma warning disable CS1591, SA1205, SA1600

namespace RxBim.Nuke.Versions
{{
    using global::Nuke.Common;

    partial interface IVersionBuild
    {{
        Target SetupEnv{versionNumber} => _ => _           
            .Executes(() => this.SetupEnvironment(""{versionNumber}""));

        Target Compile{versionNumber} => _ => _.DependsOn(SetupEnv{versionNumber}).Triggers(Compile);

        Target Restore{versionNumber} => _ => _.DependsOn(SetupEnv{versionNumber}).Triggers(Restore);

        Target Pack{versionNumber} => _ => _.DependsOn(SetupEnv{versionNumber}).Triggers(Pack);

        Target Release{versionNumber} => _ => _.DependsOn(SetupEnv{versionNumber}).Triggers(Release);

        Target Prerelease{versionNumber} => _ => _.DependsOn(SetupEnv{versionNumber}).Triggers(Prerelease);

        Target Publish{versionNumber} => _ => _.DependsOn(SetupEnv{versionNumber}).Triggers(Publish);
    }}
}}";
            return source;
        }

        private static bool TryGetVersionNumber(ISymbol fieldSymbol, out string verNumber)
        {
            verNumber = string.Empty;

            var sourceSpan = fieldSymbol.Locations.First().SourceSpan;
            var syntaxReference = fieldSymbol.DeclaringSyntaxReferences.FirstOrDefault(x =>
                x.Span.Start <= sourceSpan.Start && x.Span.End >= sourceSpan.End);

            if (syntaxReference?.GetSyntax().FindNode(sourceSpan) is not VariableDeclaratorSyntax
                fieldDeclarationSyntax)
                return false;

            var appVerArgCreation = fieldDeclarationSyntax.DescendantNodes()
                .OfType<ObjectCreationExpressionSyntax>()
                .FirstOrDefault(x => x.Type is IdentifierNameSyntax { Identifier: { Text: "ApplicationVersion" } });

            var arg = appVerArgCreation?.ArgumentList?.Arguments.FirstOrDefault();
            if (arg?.Expression is not LiteralExpressionSyntax expressionSyntax)
                return false;

            verNumber = expressionSyntax.Token.ValueText;

            return !string.IsNullOrEmpty(verNumber);
        }
    }
}