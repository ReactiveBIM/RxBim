namespace RxBim.Nuke.Generators
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using static Constants;

    /// <summary>
    /// Utilities for actions source.
    /// </summary>
    internal static class GitHubActionsSourceUtils
    {
        /// <summary>
        /// Returns actions for versions source.
        /// </summary>
        /// <param name="actionsAttribute">Source action attribute data.</param>
        /// <param name="versionNumbers">Version numbers collection.</param>
        /// <param name="actionName">Source action name.</param>
        public static string GetVersionActionsSource(
            AttributeData actionsAttribute,
            IEnumerable<string> versionNumbers,
            out string actionName)
        {
            actionName = string.Empty;
            var syntaxReference = actionsAttribute.ApplicationSyntaxReference;
            if (syntaxReference is null)
                return string.Empty;

            var rootNode = syntaxReference.SyntaxTree.GetRoot();

            var usingLines = rootNode.GetUsingDirectives();

            var sourceSpan = syntaxReference.Span;
            var attNode = rootNode.FindNode(sourceSpan);

            var nameTokenNullable = GetTokenForActionName(attNode);
            if (!nameTokenNullable.HasValue)
                return string.Empty;

            var nameToken = nameTokenNullable.Value;

            var targetsInitializerNode = GetInvokeTargets(attNode);
            if (targetsInitializerNode is null)
                return string.Empty;

            actionName = nameTokenNullable.Value.ValueText;

            var attLines = versionNumbers
                .Select(versionNumber => attNode.ReplaceSyntax(
                    new[] { targetsInitializerNode },
                    (_, _) => AddSetVersionTargetToInitializer(targetsInitializerNode, versionNumber),
                    new[] { nameToken },
                    (_, _) => CreateTokenForNameWithVersion(nameToken, versionNumber),
                    null,
                    null))
                .Select(newAttNode => $"[{newAttNode.GetText()}]")
                .ToList();

            return $$"""
                // {{AutoGeneratedFileHeader}}
                {{usingLines}}
                {{string.Join($"{Environment.NewLine}{Environment.NewLine}", attLines)}}
                partial class Build
                {
                }
                """;
        }

        private static SyntaxToken? GetTokenForActionName(SyntaxNode attNode)
        {
            var argumentSyntax = attNode
                .GetChildNode<AttributeArgumentListSyntax>()
                ?.GetChildNode<AttributeArgumentSyntax>(x => x.Expression is LiteralExpressionSyntax);

            return (argumentSyntax?.Expression as LiteralExpressionSyntax)?.Token;
        }

        private static InitializerExpressionSyntax? GetInvokeTargets(SyntaxNode attNode)
        {
            var argumentSyntax = attNode
                .GetChildNode<AttributeArgumentListSyntax>()
                ?.GetChildNode<AttributeArgumentSyntax>(syntax =>
                    syntax.NameEquals != null &&
                    syntax.NameEquals.Name.ChildTokens()
                        .Any(token => token.ValueText.Equals("InvokedTargets")));

            return (argumentSyntax?.Expression as ImplicitArrayCreationExpressionSyntax)?.Initializer;
        }

        private static SyntaxNode AddSetVersionTargetToInitializer(
            InitializerExpressionSyntax initializer,
            string versionNumber)
        {
            var valueText = $"{SetVersion}{versionNumber}";
            var text = $"\"{valueText}\"";

            var newExpr = initializer.Expressions
                .Insert(0,
                    SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression,
                        SyntaxFactory.Token(SyntaxTriviaList.Empty,
                            SyntaxKind.StringLiteralToken,
                            text,
                            valueText,
                            SyntaxTriviaList.Empty)));

            return SyntaxFactory.InitializerExpression(SyntaxKind.ArrayInitializerExpression, newExpr);
        }

        private static SyntaxToken CreateTokenForNameWithVersion(SyntaxToken nameToken, string versionNumber)
        {
            var valueText = $"{nameToken.ValueText}{versionNumber}";
            var text = $"\"{valueText}\"";
            var newNameToken = SyntaxFactory.Token(nameToken.LeadingTrivia,
                SyntaxKind.StringLiteralToken,
                text,
                valueText,
                nameToken.TrailingTrivia);
            return newNameToken;
        }
    }
}